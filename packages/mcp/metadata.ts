/**
 * Auto-generated MCP metadata
 * Generated at: 2025-09-26T09:37:23.747Z
 * DO NOT EDIT - This file is automatically generated by scripts/extract-tools.ts
 */

export interface ToolMetadata {
  name: string;
  description: string;
  category: string;
  parameters?: Record<string, any>;
}

export interface PromptMetadata {
  name: string;
  description: string;
  category: string;
}

export interface MCPMetadata {
  tools: ToolMetadata[];
  prompts: PromptMetadata[];
  resources: any[];
}

export const metadata: MCPMetadata = {
  "tools": [
    {
      "name": "checkMonitors",
      "description": "Check all monitors and their statuses.",
      "category": "Core"
    },
    {
      "name": "getDashboard",
      "description": "Get detailed information about a specific dashboard by ID.",
      "category": "Core"
    },
    {
      "name": "getDatasetFields",
      "description": "List all fields in a dataset.",
      "category": "Core"
    },
    {
      "name": "getMonitorHistory",
      "description": "Get recent check history of monitor. Use the checkMonitors() tool to list all the monitors.",
      "category": "Core"
    },
    {
      "name": "getSavedQueries",
      "description": "Retrieve saved/starred queries from Axiom - shows APL queries that users have bookmarked for reuse",
      "category": "Core"
    },
    {
      "name": "listDashboards",
      "description": "List all available dashboards. Shows user-created dashboards with their metadata.",
      "category": "Core"
    },
    {
      "name": "listDatasets",
      "description": "List all available datasets. For datasets you are curious about, use getDatasetFields() tool to find their schema.",
      "category": "Core"
    },
    {
      "name": "queryDataset",
      "description": "# Instructions 1. Query Axiom datasets using Axiom Processing Language (APL). The query must be a valid APL query string. 2. ALWAYS get the schema of the dataset before running queries rather than guessing. You can do this by getting a single event and projecting all fields. 3. Keep in mind that there",
      "category": "Core"
    }
  ],
  "prompts": [
    {
      "name": "correlate-events-across-datasets",
      "description": "Find patterns and correlations between events across multiple datasets",
      "category": "Core"
    },
    {
      "name": "data-quality-investigation",
      "description": "Investigate data quality issues including missing data, inconsistencies, and collection problems",
      "category": "Core"
    },
    {
      "name": "detect-anomalies-in-events",
      "description": "Generic anomaly detection using statistical analysis and pattern recognition across any event dataset",
      "category": "Core"
    },
    {
      "name": "establish-performance-baseline",
      "description": "Establish performance baselines for a dataset to enable effective monitoring and anomaly detection",
      "category": "Core"
    },
    {
      "name": "explore-unknown-dataset",
      "description": "Systematic exploration of an unknown dataset to understand its structure, content, and potential use cases",
      "category": "Core"
    },
    {
      "name": "monitor-health-analysis",
      "description": "Comprehensive analysis of monitor health, alert patterns, and effectiveness",
      "category": "Core"
    }
  ],
  "resources": []
};

export const toolsByCategory = metadata.tools.reduce((acc, tool) => {
  if (!acc[tool.category]) {
    acc[tool.category] = [];
  }
  acc[tool.category].push(tool);
  return acc;
}, {} as Record<string, ToolMetadata[]>);

export const promptsByCategory = metadata.prompts.reduce((acc, prompt) => {
  if (!acc[prompt.category]) {
    acc[prompt.category] = [];
  }
  acc[prompt.category].push(prompt);
  return acc;
}, {} as Record<string, PromptMetadata[]>);
