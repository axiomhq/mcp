/**
 * Auto-generated MCP metadata
 * Generated at: 2025-08-26T11:03:44.032Z
 * DO NOT EDIT - This file is automatically generated by scripts/extract-tools.ts
 */

export interface ToolMetadata {
  name: string;
  description: string;
  category: string;
  parameters?: Record<string, any>;
}

export interface PromptMetadata {
  name: string;
  description: string;
  category: string;
}

export interface MCPMetadata {
  tools: ToolMetadata[];
  prompts: PromptMetadata[];
  resources: any[];
}

export const metadata: MCPMetadata = {
  "tools": [
    {
      "name": "checkMonitors",
      "description": "Check all monitors and their statuses.",
      "category": "Core"
    },
    {
      "name": "getDatasetFields",
      "description": "List all fields in a dataset.",
      "category": "Core"
    },
    {
      "name": "getMonitorHistory",
      "description": "Get recent check history of monitor. Use the checkMonitors() tool to list all the monitors.",
      "category": "Core"
    },
    {
      "name": "getSavedQueries",
      "description": "Retrieve saved/starred queries from Axiom - shows APL queries that users have bookmarked for reuse",
      "category": "Core"
    },
    {
      "name": "listDatasets",
      "description": "List all available datasets. For datasets you are curious about, use getDatasetFields() tool to find their schema.",
      "category": "Core"
    },
    {
      "name": "queryDataset",
      "description": "# Instructions 1. Query Axiom datasets using Axiom Processing Language (APL). The query must be a valid APL query string. 2. ALWAYS get the schema of the dataset before running queries rather than guessing. You can do this by getting a single event and projecting all fields. 3. Keep in mind that there",
      "category": "Core"
    },
    {
      "name": "genai-analyzeCosts",
      "description": "Analyze and breakdown costs for GenAI operations across models and capabilities",
      "category": "OpenTelemetry"
    },
    {
      "name": "genai-analyzeTokenUsage",
      "description": "Analyze token consumption patterns across models, capabilities, and time",
      "category": "OpenTelemetry"
    },
    {
      "name": "genai-analyzeToolUsage",
      "description": "Analyze AI tool/function usage patterns and performance",
      "category": "OpenTelemetry"
    },
    {
      "name": "genai-compareModels",
      "description": "Compare performance, cost, and reliability metrics across different AI models",
      "category": "OpenTelemetry"
    },
    {
      "name": "genai-findErrors",
      "description": "Find and analyze errors in GenAI operations",
      "category": "OpenTelemetry"
    },
    {
      "name": "genai-getCapabilityMetrics",
      "description": "Get detailed metrics for specific GenAI capabilities (e.g., chat, completion, embedding)",
      "category": "OpenTelemetry"
    },
    {
      "name": "genai-getModelPerformance",
      "description": "Get performance metrics for AI models including latency, throughput, and reliability",
      "category": "OpenTelemetry"
    },
    {
      "name": "genai-getOverview",
      "description": "Get an overview of GenAI operations including request counts, token usage, costs, and error rates",
      "category": "OpenTelemetry"
    },
    {
      "name": "otel-findSimilarTraces",
      "description": "Find traces with similar patterns to a reference trace based on services, operations, and characteristics",
      "category": "OpenTelemetry"
    },
    {
      "name": "otel-findTraceAnomalies",
      "description": "Find traces that are statistical outliers in duration or span count",
      "category": "OpenTelemetry"
    },
    {
      "name": "otel-findTraces",
      "description": "Search for traces by various criteria including service name, operation name, errors, and duration",
      "category": "OpenTelemetry"
    },
    {
      "name": "otel-getErrorBreakdown",
      "description": "Get a breakdown of the top 20 most common errors across all services and operations, including error counts, affected services, and example operations.",
      "category": "OpenTelemetry"
    },
    {
      "name": "otel-getOperationMetrics",
      "description": "Get detailed metrics for a specific operation within a service, including latency percentiles, error rates, and throughput over time.",
      "category": "OpenTelemetry"
    },
    {
      "name": "otel-getServiceMetrics",
      "description": "Get detailed metrics for a specific OpenTelemetry service by it",
      "category": "OpenTelemetry"
    },
    {
      "name": "otel-getTraceCriticalPath",
      "description": "Find the critical path (longest chain) through a trace",
      "category": "OpenTelemetry"
    },
    {
      "name": "otel-getTraceSpans",
      "description": "Get all spans for a specific trace, showing the complete trace timeline with service names, operation names, durations, and status information.",
      "category": "OpenTelemetry"
    },
    {
      "name": "otel-listOperations",
      "description": "List all available OpenTelemetry operations for a service. For operations you are curious about, use otel-getServiceMetrics and ${ToolGetErrorBreakdown} tools to explore further.",
      "category": "OpenTelemetry"
    },
    {
      "name": "otel-listServices",
      "description": "List all available OpenTelemetry services. For services you are curious about, use ${ToolListOperations}, otel-getServiceMetrics and ${ToolGetErrorBreakdown} tools.",
      "category": "OpenTelemetry"
    }
  ],
  "prompts": [
    {
      "name": "correlate-events-across-datasets",
      "description": "Find patterns and correlations between events across multiple datasets",
      "category": "Core"
    },
    {
      "name": "data-quality-investigation",
      "description": "Investigate data quality issues including missing data, inconsistencies, and collection problems",
      "category": "Core"
    },
    {
      "name": "detect-anomalies-in-events",
      "description": "Generic anomaly detection using statistical analysis and pattern recognition across any event dataset",
      "category": "Core"
    },
    {
      "name": "establish-performance-baseline",
      "description": "Establish performance baselines for a dataset to enable effective monitoring and anomaly detection",
      "category": "Core"
    },
    {
      "name": "explore-unknown-dataset",
      "description": "Systematic exploration of an unknown dataset to understand its structure, content, and potential use cases",
      "category": "Core"
    },
    {
      "name": "monitor-health-analysis",
      "description": "Comprehensive analysis of monitor health, alert patterns, and effectiveness",
      "category": "Core"
    },
    {
      "name": "distributed-system-health-check",
      "description": "Comprehensive health check across all services in a distributed system",
      "category": "OpenTelemetry"
    },
    {
      "name": "investigate-service-outage",
      "description": "Systematic approach to investigating service outages and performance degradation",
      "category": "OpenTelemetry"
    },
    {
      "name": "new-service-health-baseline",
      "description": "Establish performance baselines and monitoring strategy for a new service",
      "category": "OpenTelemetry"
    },
    {
      "name": "performance-degradation-analysis",
      "description": "Comprehensive analysis of service performance issues and optimization opportunities",
      "category": "OpenTelemetry"
    },
    {
      "name": "trace-analysis-workflow",
      "description": "Detailed workflow for analyzing distributed traces and identifying bottlenecks",
      "category": "OpenTelemetry"
    }
  ],
  "resources": []
};

export const toolsByCategory = metadata.tools.reduce((acc, tool) => {
  if (!acc[tool.category]) {
    acc[tool.category] = [];
  }
  acc[tool.category].push(tool);
  return acc;
}, {} as Record<string, ToolMetadata[]>);

export const promptsByCategory = metadata.prompts.reduce((acc, prompt) => {
  if (!acc[prompt.category]) {
    acc[prompt.category] = [];
  }
  acc[prompt.category].push(prompt);
  return acc;
}, {} as Record<string, PromptMetadata[]>);
